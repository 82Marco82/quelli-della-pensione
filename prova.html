<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Statistiche ‚Ä¢ Quelli della pensione</title>
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#f4f6f8; --card:#ffffff; --text:#111827; --muted:#6b7280; --border:#e5e7eb;
      --shadow:0 6px 20px rgba(0,0,0,.08); --pill:#eeeeee; --logo1:#111; --logo2:#333; --btn:#111;
      --okBg:#dcfce7; --okText:#166534; --okBd:rgba(34,197,94,.35);
      --warnBg:#fff7ed; --warnText:#9a3412; --warnBd:rgba(249,115,22,.35);
      --riskBg:#ffe4e6; --riskText:#9f1239; --riskBd:rgba(244,63,94,.35);
    }
    body.dark{
      --bg:#0f1115; --card:#171a21; --text:#e5e7eb; --muted:#a1a1aa; --border:#2a2f3a;
      --shadow:0 10px 28px rgba(0,0,0,.45); --pill:#222631; --logo1:#0b0e14; --logo2:#2a3242; --btn:#0b0e14;
      --okBg:rgba(34,197,94,.15); --okText:#86efac; --okBd:rgba(34,197,94,.35);
      --warnBg:rgba(249,115,22,.14); --warnText:#fdba74; --warnBd:rgba(249,115,22,.35);
      --riskBg:rgba(244,63,94,.16); --riskText:#fda4af; --riskBd:rgba(244,63,94,.35);
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,system-ui;background:var(--bg);color:var(--text);transition:.2s}
    .wrap{max-width:860px;margin:auto;padding:16px}
    .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:14px;box-shadow:var(--shadow);margin:12px 0}
    .header{text-align:center}
    .logo{
      width:80px;height:80px;border-radius:999px;background:linear-gradient(135deg,var(--logo1),var(--logo2));
      margin:auto;display:flex;align-items:center;justify-content:center;color:#fff;font-family:'Bebas Neue';
      font-size:34px;letter-spacing:2px;cursor:pointer;transform-style:preserve-3d;will-change:transform;
    }
    .logo.spin{animation:coinSpin 900ms ease-in-out}
    @keyframes coinSpin{0%{transform:rotateY(0)}50%{transform:rotateY(180deg)}100%{transform:rotateY(360deg)}}
    h1{font-family:'Bebas Neue';letter-spacing:2px;font-size:48px;margin:10px 0 0;text-transform:uppercase}
    .subtitle{color:var(--muted);font-size:14px}
    .nav{display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;font-size:14px}
    .nav a{color:var(--text);text-decoration:none;font-weight:800}
    .fab{position:fixed;right:16px;bottom:16px;width:54px;height:54px;border-radius:999px;border:1px solid var(--border);background:var(--card);box-shadow:var(--shadow);cursor:pointer;font-size:22px}

    .pill{display:inline-block;background:var(--pill);border-radius:999px;padding:6px 10px;margin:4px 6px 0 0;font-weight:900;border:1px solid var(--border)}
    .muted{color:var(--muted)}
    .line{margin-top:8px}

    .sectionTitle{
      font-family:'Bebas Neue';letter-spacing:2px;font-size:28px;margin:0 0 10px 0;text-transform:uppercase;text-align:center;
    }

    .grid{display:grid;grid-template-columns:1fr;gap:12px}
    @media(min-width:780px){ .grid{grid-template-columns:1fr 1fr} }

    .miniCard{
      border:1px solid var(--border);
      border-radius:16px;
      padding:12px;
      background:rgba(0,0,0,.02);
    }
    body.dark .miniCard{background:rgba(255,255,255,.03)}
    .miniHead{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
    .miniHead b{letter-spacing:.6px;text-transform:uppercase}
    .bigNum{font-family:'Bebas Neue';font-size:56px;line-height:1}

    .row{
      display:flex;align-items:center;justify-content:space-between;gap:12px;
      border:1px solid var(--border);border-radius:14px;padding:10px 12px;margin-top:10px;
      background:transparent;
      font-weight:800;
    }
    .left{display:flex;align-items:center;gap:10px;min-width:0}
    .avatar{width:44px;height:44px;border-radius:999px;border:1px solid var(--border);object-fit:cover;background:#000;flex:0 0 auto}
    .name{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .meta{color:var(--muted);font-weight:800;font-size:13px;margin-top:2px}
    .val{font-family:'Bebas Neue';font-size:34px;line-height:1;letter-spacing:1px}

    .controls{
      display:flex;gap:10px;flex-wrap:wrap;justify-content:space-between;align-items:center
    }
    .select{
      border:1px solid var(--border);background:var(--card);color:var(--text);
      padding:10px 12px;border-radius:14px;font-weight:900;outline:none;
    }

    .toast{
      position:fixed;left:50%;bottom:18px;transform:translateX(-50%) translateY(20px);
      opacity:0;pointer-events:none;background:var(--card);color:var(--text);
      border:1px solid var(--border);border-radius:14px;padding:10px 12px;font-weight:900;
      box-shadow:var(--shadow);transition:.18s ease;z-index:9999;max-width:min(92vw,520px);text-align:center;
    }
    .toast.show{opacity:1;transform:translateX(-50%) translateY(0)}
    .toast.ok{border-color:var(--okBd)}
    .toast.err{border-color:var(--riskBd)}
  </style>
</head>

<body>
<div class="wrap">
  <div class="header">
    <div id="logoCoin" class="logo" title="Tocca per girare ü™ô">QDP</div>
    <h1>Statistiche</h1>
    <div class="subtitle">Quelli della pensione ‚Ä¢ Calcetto a 6</div>
  </div>

  <div class="card">
    <div class="controls">
      <div class="muted" style="font-weight:900">Filtri</div>
      <div style="display:flex;gap:10px;flex-wrap:wrap">
        <select id="seasonSel" class="select" title="Stagione">
          <option value="all">Tutte le stagioni</option>
        </select>
        <select id="scopeSel" class="select" title="Conteggio presenze">
          <option value="called">Presenze = convocati (called_up)</option>
          <option value="teams">Presenze = in squadra (team A/B)</option>
        </select>
      </div>
    </div>
    <div id="status" class="muted" style="margin-top:10px">Caricamento‚Ä¶</div>
  </div>

  <div class="card">
    <div class="sectionTitle">Riepilogo</div>
    <div class="grid">
      <div class="miniCard">
        <div class="miniHead"><b>Partite totali</b><span class="pill" id="pMatches">‚Äî</span></div>
        <div class="bigNum" id="nMatches">‚Äî</div>
        <div class="muted" style="font-weight:800">Nel filtro selezionato</div>
      </div>

      <div class="miniCard">
        <div class="miniHead"><b>Partite concluse</b><span class="pill" id="pEnded">‚Äî</span></div>
        <div class="bigNum" id="nEnded">‚Äî</div>
        <div class="muted" style="font-weight:800">Con risultato inserito</div>
      </div>

      <div class="miniCard">
        <div class="miniHead"><b>Voti MVP</b><span class="pill" id="pVotes">‚Äî</span></div>
        <div class="bigNum" id="nVotes">‚Äî</div>
        <div class="muted" style="font-weight:800">Somma di tutti i voti</div>
      </div>

      <div class="miniCard">
        <div class="miniHead"><b>Gol registrati</b><span class="pill" id="pGoals">‚Äî</span></div>
        <div class="bigNum" id="nGoals">‚Äî</div>
        <div class="muted" style="font-weight:800">
          Se non hai la tabella marcatori, prova a leggere <code>scorers_text</code>
        </div>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="sectionTitle">Classifiche</div>

    <div class="grid">
      <div class="miniCard">
        <div class="miniHead"><b>üë• Presenze</b><span class="pill">Top 12</span></div>
        <div id="listPres">‚Äî</div>
      </div>

      <div class="miniCard">
        <div class="miniHead"><b>‚öΩ Gol</b><span class="pill">Top 12</span></div>
        <div id="listGoals">‚Äî</div>
      </div>

      <div class="miniCard">
        <div class="miniHead"><b>üèÜ MVP (finali)</b><span class="pill">Top 12</span></div>
        <div id="listMvp">‚Äî</div>
        <div class="muted" style="font-weight:800;margin-top:8px">
          Calcola l‚ÄôMVP per partita in base ai voti. In caso di parit√† assegna 1 MVP a ciascuno.
        </div>
      </div>

      <div class="miniCard">
        <div class="miniHead"><b>‚≠êÔ∏è MVP (voti ricevuti)</b><span class="pill">Top 12</span></div>
        <div id="listVotes">‚Äî</div>
        <div class="muted" style="font-weight:800;margin-top:8px">
          Questa √® la somma di tutti i voti ricevuti, non ‚Äúvittorie MVP‚Äù.
        </div>
      </div>
    </div>
  </div>

  <div class="card nav muted">
    <a href="index.html">üè† Home</a>
    <a href="storico.html">üìö Storico</a>
    <a href="marcatori.html">‚öΩ Marcatori</a>
    <a href="mvp.html">üèÜ Vota MVP</a>
    <a href="foto.html">üì∏ Foto</a>
    <a href="componenti.html">üë• Componenti</a>
    <a href="admin.html">üîê Admin</a>
  </div>
</div>

<div id="toast" class="toast">‚Äî</div>
<button id="themeToggle" class="fab">üåô</button>

<script src="config.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.js"></script>
<script>
/* THEME */
const themeBtn = document.getElementById("themeToggle");
function setTheme(mode){
  document.body.classList.toggle("dark", mode === "dark");
  themeBtn.textContent = (mode === "dark") ? "‚òÄÔ∏è" : "üåô";
  localStorage.setItem("qdp_theme", mode);
}
setTheme(localStorage.getItem("qdp_theme") === "dark" ? "dark" : "light");
themeBtn.onclick = () => setTheme(document.body.classList.contains("dark") ? "light" : "dark");

/* LOGO MONETA */
const logoCoin = document.getElementById("logoCoin");
function spinLogo(){
  logoCoin.classList.remove("spin");
  void logoCoin.offsetWidth;
  logoCoin.classList.add("spin");
}
logoCoin.addEventListener("click", spinLogo);
logoCoin.addEventListener("touchstart", spinLogo, {passive:true});

/* SUPABASE */
if(!window.SUPABASE_URL || !window.SUPABASE_ANON_KEY){
  alert("config.js non caricato o non valido");
  throw new Error("Missing config");
}
const client = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

/* TOAST */
const toastEl = document.getElementById("toast");
let toastTimer = null;
function showToast(msg, type="ok"){
  toastEl.textContent = msg;
  toastEl.className = "toast show " + (type==="err" ? "err" : "ok");
  clearTimeout(toastTimer);
  toastTimer = setTimeout(()=> toastEl.className = "toast", 1800);
}

/* DOM */
const statusEl = document.getElementById("status");
const seasonSel = document.getElementById("seasonSel");
const scopeSel = document.getElementById("scopeSel");

const nMatches = document.getElementById("nMatches");
const nEnded   = document.getElementById("nEnded");
const nVotes   = document.getElementById("nVotes");
const nGoals   = document.getElementById("nGoals");

const pMatches = document.getElementById("pMatches");
const pEnded   = document.getElementById("pEnded");
const pVotes   = document.getElementById("pVotes");
const pGoals   = document.getElementById("pGoals");

const listPres  = document.getElementById("listPres");
const listGoals = document.getElementById("listGoals");
const listMvp   = document.getElementById("listMvp");
const listVotes = document.getElementById("listVotes");

/* AVATAR PATH */
const AVATAR_BASE = "avatars/";
const DEFAULT_AVATAR = "default.png";
function avatarUrl(filename){
  const f = String(filename || "").trim();
  return AVATAR_BASE + (f ? f : DEFAULT_AVATAR);
}
function escapeHtml(s){
  return String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}
function isEnded(m){
  return (m?.score_a !== null && m?.score_a !== undefined) &&
         (m?.score_b !== null && m?.score_b !== undefined);
}
function safeArr(v){ return Array.isArray(v) ? v : []; }

/* Seasons helper: da match_date */
function seasonFromISO(iso){
  // stagione = anno del match
  try{ return String(new Date(iso).getFullYear()); }catch(e){ return ""; }
}

function renderRow({avatar, name, sub, value}){
  return `
    <div class="row">
      <div class="left">
        <img class="avatar" src="${escapeHtml(avatarUrl(avatar))}" alt="">
        <div style="min-width:0">
          <div class="name">${escapeHtml(name)}</div>
          ${sub ? `<div class="meta">${escapeHtml(sub)}</div>` : ``}
        </div>
      </div>
      <div class="val">${escapeHtml(String(value))}</div>
    </div>
  `;
}
function renderEmpty(msg){
  return `<div class="muted" style="text-align:center;font-weight:900;margin-top:10px">${escapeHtml(msg)}</div>`;
}

/* ---- GOALS: tentativo 1 = tabella match_scorers (consigliata)
   Schema atteso (se esiste):
   - match_id (uuid/int)
   - player_id (id players)
   - goals (int)  oppure goal_count
*/
async function loadGoalsFromTable(matchIdsSet){
  // prova a leggere la tabella. Se non esiste -> lancia errore e facciamo fallback
  const { data, error } = await client
    .from("match_scorers")
    .select("match_id,player_id,goals,goal_count")
    .in("match_id", [...matchIdsSet]);

  if(error) throw error;

  const map = new Map(); // player_id -> goals
  for(const r of (data||[])){
    const pid = String(r.player_id||"");
    if(!pid) continue;
    const g = Number(r.goals ?? r.goal_count ?? 0) || 0;
    map.set(pid, (map.get(pid)||0) + g);
  }
  return map;
}

/* ---- GOALS fallback: parse matches.scorers_text
   Accetta righe tipo:
   - "Marco x2"
   - "Marco 2"
   - "Marco (2)"
   - "Marco, Marco, Tonino"  (conteggio nomi)
*/
function parseScorersTextToNameCounts(text){
  const counts = new Map(); // nameLower -> goals
  const raw = String(text||"").trim();
  if(!raw) return counts;

  const lines = raw.split(/\n+/).map(s=>s.trim()).filter(Boolean);

  for(const line of lines){
    // caso lista separata da virgola
    if(line.includes(",")){
      const parts = line.split(",").map(s=>s.trim()).filter(Boolean);
      for(const p of parts){
        const k = p.toLowerCase();
        counts.set(k, (counts.get(k)||0) + 1);
      }
      continue;
    }

    // Marco x2 / Marco 2 / Marco (2)
    const m1 = line.match(/^(.+?)\s*[xX]\s*(\d+)\s*$/);
    const m2 = line.match(/^(.+?)\s+(\d+)\s*$/);
    const m3 = line.match(/^(.+?)\s*\((\d+)\)\s*$/);

    let name = "";
    let n = 1;

    if(m1){ name = m1[1]; n = Number(m1[2]||1); }
    else if(m3){ name = m3[1]; n = Number(m3[2]||1); }
    else if(m2){ name = m2[1]; n = Number(m2[2]||1); }
    else { name = line; n = 1; }

    name = String(name||"").trim();
    if(!name) continue;

    const k = name.toLowerCase();
    counts.set(k, (counts.get(k)||0) + (Number.isFinite(n) ? n : 1));
  }

  return counts;
}

/* MAIN */
let cache = null; // { playersById, playersByNameLower, matches, votes }
async function loadAll(){
  statusEl.textContent = "Caricamento dati‚Ä¶";

  // players
  const { data: players, error: pe } = await client
    .from("players")
    .select("id,name,avatar,role,position");

  if(pe) throw pe;

  const playersById = new Map((players||[]).map(p=>[String(p.id), p]));
  const playersByNameLower = new Map();
  (players||[]).forEach(p=>{
    const k = String(p.name||"").trim().toLowerCase();
    if(k) playersByNameLower.set(k, p);
  });

  // matches (prendiamo tutto)
  const { data: matches, error: me } = await client
    .from("matches")
    .select("id,match_date,match_time,called_up,team_a,team_b,score_a,score_b,scorers_text")
    .order("match_date",{ascending:false});

  if(me) throw me;

  // votes
  const { data: votes, error: ve } = await client
    .from("mvp_votes")
    .select("match_id,voted_player");

  if(ve) throw ve;

  cache = { playersById, playersByNameLower, matches: (matches||[]), votes: (votes||[]) };
  statusEl.textContent = "Dati caricati ‚úÖ";

  // build season select
  const seasons = new Set();
  cache.matches.forEach(m=>{
    const s = seasonFromISO(m.match_date);
    if(s) seasons.add(s);
  });
  const arr = [...seasons].sort((a,b)=> Number(b)-Number(a));
  for(const s of arr){
    const opt = document.createElement("option");
    opt.value = s;
    opt.textContent = `Stagione ${s}`;
    seasonSel.appendChild(opt);
  }
}

function applyFilters(){
  if(!cache) return;

  const season = seasonSel.value || "all";
  const scope = scopeSel.value || "called";

  const matchesFiltered = cache.matches.filter(m=>{
    if(season === "all") return true;
    return seasonFromISO(m.match_date) === season;
  });

  const endedMatches = matchesFiltered.filter(isEnded);
  const matchIdsSet = new Set(matchesFiltered.map(m=>String(m.id)));

  // KPI
  nMatches.textContent = String(matchesFiltered.length);
  nEnded.textContent   = String(endedMatches.length);

  pMatches.textContent = "üìå";
  pEnded.textContent   = "üèÅ";

  // Votes KPI
  const votesFiltered = cache.votes.filter(v => matchIdsSet.has(String(v.match_id)));
  nVotes.textContent = String(votesFiltered.length);
  pVotes.textContent = "üó≥Ô∏è";

  // PRESENZE
  const presMap = new Map(); // player_id -> count
  for(const m of matchesFiltered){
    const ids = (scope === "teams")
      ? [...safeArr(m.team_a), ...safeArr(m.team_b)]
      : safeArr(m.called_up);

    // evita doppioni nella stessa partita
    const uniq = new Set(ids.map(String));
    for(const id of uniq){
      if(!id) continue;
      presMap.set(id, (presMap.get(id)||0) + 1);
    }
  }

  // MVP "finali" per partita (winner/tie)
  const votesByMatch = new Map(); // match_id -> Map(player_id -> votes)
  for(const v of votesFiltered){
    const mid = String(v.match_id||"");
    const pid = String(v.voted_player||"");
    if(!mid || !pid) continue;
    if(!votesByMatch.has(mid)) votesByMatch.set(mid, new Map());
    const m = votesByMatch.get(mid);
    m.set(pid, (m.get(pid)||0) + 1);
  }
  const mvpFinalMap = new Map(); // player_id -> mvp_wins (ties count too)
  for(const [mid, pm] of votesByMatch.entries()){
    if(pm.size === 0) continue;
    let top = 0;
    for(const c of pm.values()) top = Math.max(top, c);
    const winners = [...pm.entries()].filter(([,c])=>c===top).map(([pid])=>pid);
    for(const pid of winners){
      mvpFinalMap.set(pid, (mvpFinalMap.get(pid)||0) + 1);
    }
  }

  // Voti ricevuti (somma)
  const votesSumMap = new Map(); // player_id -> total votes
  for(const [mid, pm] of votesByMatch.entries()){
    for(const [pid, c] of pm.entries()){
      votesSumMap.set(pid, (votesSumMap.get(pid)||0) + c);
    }
  }

  // GOALS
  (async ()=>{
    let goalsByPlayerId = new Map();
    let totalGoals = 0;

    // tentativo tabella
    try{
      goalsByPlayerId = await loadGoalsFromTable(matchIdsSet);
    }catch(e){
      // fallback parse scorers_text (solo partite concluse)
      const nameCounts = new Map(); // nameLower -> goals
      for(const m of endedMatches){
        const counts = parseScorersTextToNameCounts(m.scorers_text);
        for(const [k, g] of counts.entries()){
          nameCounts.set(k, (nameCounts.get(k)||0) + g);
        }
      }
      // mappa nomi -> player_id se possibile
      const map = new Map();
      for(const [nameLower, g] of nameCounts.entries()){
        const p = cache.playersByNameLower.get(nameLower);
        if(p?.id){
          const pid = String(p.id);
          map.set(pid, (map.get(pid)||0) + g);
        }
      }
      goalsByPlayerId = map;
    }

    for(const g of goalsByPlayerId.values()) totalGoals += (Number(g)||0);
    nGoals.textContent = String(totalGoals);
    pGoals.textContent = "‚öΩ";

    // Render lists
    renderLeaderboardPres(presMap);
    renderLeaderboardGoals(goalsByPlayerId);
    renderLeaderboardMvp(mvpFinalMap);
    renderLeaderboardVotes(votesSumMap);

  })().catch(err=>{
    console.error(err);
    showToast("Errore calcolo statistiche", "err");
  });
}

function topRowsFromMap(map, valueLabel){
  const rows = [...map.entries()]
    .map(([id, val])=>{
      const p = cache.playersById.get(String(id));
      return {
        id,
        val: Number(val)||0,
        name: p?.name || String(id),
        avatar: p?.avatar || DEFAULT_AVATAR,
        sub: valueLabel
      };
    })
    .filter(r=>r.val>0)
    .sort((a,b)=> b.val - a.val || String(a.name).localeCompare(String(b.name),"it"));

  return rows;
}

function renderLeaderboardPres(presMap){
  const rows = topRowsFromMap(presMap, "presenze");
  if(rows.length === 0){
    listPres.innerHTML = renderEmpty("Nessun dato presenze.");
    return;
  }
  const top = rows.slice(0,12);
  listPres.innerHTML = top.map(r=>renderRow({
    avatar:r.avatar,
    name:r.name,
    sub:(r.val===1 ? "1 presenza" : `${r.val} presenze`),
    value:r.val
  })).join("");
}

function renderLeaderboardGoals(goalsMap){
  const rows = topRowsFromMap(goalsMap, "gol");
  if(rows.length === 0){
    listGoals.innerHTML = renderEmpty("Nessun gol registrato (o tabella marcatori assente).");
    return;
  }
  const top = rows.slice(0,12);
  listGoals.innerHTML = top.map(r=>renderRow({
    avatar:r.avatar,
    name:r.name,
    sub:(r.val===1 ? "1 gol" : `${r.val} gol`),
    value:r.val
  })).join("");
}

function renderLeaderboardMvp(mvpMap){
  const rows = topRowsFromMap(mvpMap, "mvp");
  if(rows.length === 0){
    listMvp.innerHTML = renderEmpty("Nessun MVP calcolabile (serve almeno un voto).");
    return;
  }
  const top = rows.slice(0,12);
  listMvp.innerHTML = top.map(r=>renderRow({
    avatar:r.avatar,
    name:r.name,
    sub:(r.val===1 ? "1 MVP" : `${r.val} MVP`),
    value:r.val
  })).join("");
}

function renderLeaderboardVotes(votesSumMap){
  const rows = topRowsFromMap(votesSumMap, "voti");
  if(rows.length === 0){
    listVotes.innerHTML = renderEmpty("Nessun voto trovato.");
    return;
  }
  const top = rows.slice(0,12);
  listVotes.innerHTML = top.map(r=>renderRow({
    avatar:r.avatar,
    name:r.name,
    sub:(r.val===1 ? "1 voto ricevuto" : `${r.val} voti ricevuti`),
    value:r.val
  })).join("");
}

/* INIT */
async function init(){
  try{
    await loadAll();
    applyFilters();
  }catch(e){
    console.error(e);
    statusEl.textContent = "Errore caricamento";
    showToast("Errore caricamento dati (Supabase)", "err");
  }
}
seasonSel.addEventListener("change", applyFilters);
scopeSel.addEventListener("change", applyFilters);
init();
</script>
</body>
</html>
